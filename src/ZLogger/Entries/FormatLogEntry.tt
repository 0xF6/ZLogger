<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    static string CreateTypeArgument(int i)
    {
        return string.Join(", ", Enumerable.Range(0, i).Select(x => "T" + (x + 1)));
    }

    static string CreateParameters(int i)
    {
        return string.Join(", ", Enumerable.Range(0, i).Select(x => "T" + (x + 1) + " arg" + (x + 1)));
    }


    static string CreateStateParameterNames(int i)
    {
        return string.Join(", ", Enumerable.Range(0, i).Select(x => "state.Arg" + (x + 1)));
    }
#>
using Cysharp.Text;
using System.Buffers;
using System.Collections.Concurrent;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Runtime.CompilerServices;

namespace ZLogger.Entries
{
<# for(var i = 1; i <= 16; i++) { #>
    internal struct FormatLogState<TPayload, <#= CreateTypeArgument(i) #>> : IZLoggerState
    {
        public readonly TPayload Payload;
        public readonly string? Format;
<# for(var j = 0; j < i; j++) { #>
        public readonly T<#= j + 1 #> Arg<#= j + 1 #>;
<# } #>

        public FormatLogState([AllowNull]TPayload payload, string? format, <#= CreateParameters(i) #>)
        {
            Payload = payload;
            Format = format;
<# for(var j = 0; j < i; j++) { #>
            Arg<#= j + 1 #> = arg<#= j + 1 #>;
<# } #>
        }

        public IZLoggerEntry CreateLogEntry(LogInfo logInfo)
        {
            return FormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>>.Create(logInfo, this);
        }
    }

    internal struct PreparedFormatLogState<TPayload, <#= CreateTypeArgument(i) #>> : IZLoggerState
    {
        public readonly TPayload Payload;
        public readonly Utf8PreparedFormat<<#= CreateTypeArgument(i) #>> Format;
<# for(var j = 0; j < i; j++) { #>
        public readonly T<#= j + 1 #> Arg<#= j + 1 #>;
<# } #>

        public PreparedFormatLogState([AllowNull]TPayload payload, Utf8PreparedFormat<<#= CreateTypeArgument(i) #>> format, <#= CreateParameters(i) #>)
        {
            Payload = payload;
            Format = format;
<# for(var j = 0; j < i; j++) { #>
            Arg<#= j + 1 #> = arg<#= j + 1 #>;
<# } #>
        }

        public IZLoggerEntry CreateLogEntry(LogInfo logInfo)
        {
            return PreparedFormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>>.Create(logInfo, this);
        }
    }

    internal class FormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>> : IZLoggerEntry
    {
        static readonly ConcurrentQueue<FormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>>> cache = new ConcurrentQueue<FormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>>>();

        FormatLogState<TPayload, <#= CreateTypeArgument(i) #>> state;

        public LogInfo LogInfo { get; private set; }

        FormatLogEntry()
        {
        }

        public static FormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>> Create(in LogInfo logInfo, in FormatLogState<TPayload, <#= CreateTypeArgument(i) #>> state)
        {
            if (!cache.TryDequeue(out var result))
            {
                result = new FormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>>();
            }

            result.LogInfo = logInfo;
            result.state = state;
            return result;
        }

        public void FormatUtf8(IBufferWriter<byte> writer, ZLoggerOptions options, Utf8JsonWriter? jsonWriter)
        {
            if (options.IsStructuredLogging && jsonWriter != null)
            {
                using (var sb = ZString.CreateUtf8StringBuilder(true))
                {
                    sb.AppendFormat(state.Format, <#= CreateStateParameterNames(i) #>);
                    jsonWriter.WriteString(options.MessagePropertyName, sb.AsSpan());
                }

                jsonWriter.WritePropertyName(options.PayloadPropertyName);
                JsonSerializer.Serialize(jsonWriter, state.Payload, options.JsonSerializerOptions);
            }
            else
            {
                if (state.Format != null)
                {
                    ZString.Utf8Format(writer, state.Format, <#= CreateStateParameterNames(i) #>);
                }
                else
                {
                    var writer2 = options.GetThradStaticUtf8JsonWriter(writer);
                    try
                    {
                        JsonSerializer.Serialize(writer2, state.Payload, options.JsonSerializerOptions);
                        writer2.Flush();
                    }
                    finally
                    {
                        writer2.Reset();
                    }
                }
            }
        }

        public void Return()
        {
            state = default;
            LogInfo = default!;
            cache.Enqueue(this);
        }
        
        public void SwitchCasePayload<TPayload1>(System.Action<IZLoggerEntry, TPayload1, object?> payloadCallback, object? state)
        {
            if (typeof(TPayload1) == typeof(TPayload))
            {
                payloadCallback(this, Unsafe.As<TPayload, TPayload1>(ref Unsafe.AsRef(this.state.Payload)), state);
            }
        }

        public object? GetPayload()
        {
            return state.Payload;
        }
    }

    internal class PreparedFormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>> : IZLoggerEntry
    {
        static readonly ConcurrentQueue<PreparedFormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>>> cache = new ConcurrentQueue<PreparedFormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>>>();

        PreparedFormatLogState<TPayload, <#= CreateTypeArgument(i) #>> state;

        public LogInfo LogInfo { get; private set; }

        PreparedFormatLogEntry()
        {
        }

        public static PreparedFormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>> Create(in LogInfo logInfo, in PreparedFormatLogState<TPayload, <#= CreateTypeArgument(i) #>> state)
        {
            if (!cache.TryDequeue(out var result))
            {
                result = new PreparedFormatLogEntry<TPayload, <#= CreateTypeArgument(i) #>>();
            }

            result.LogInfo = logInfo;
            result.state = state;
            return result;
        }

        public void FormatUtf8(IBufferWriter<byte> writer, ZLoggerOptions options, Utf8JsonWriter? jsonWriter)
        {
            if (options.IsStructuredLogging && jsonWriter != null)
            {
                var sb = ZString.CreateUtf8StringBuilder(true);
                try
                {
                    state.Format.FormatTo(ref sb, <#= CreateStateParameterNames(i) #>);
                    jsonWriter.WriteString(options.MessagePropertyName, sb.AsSpan());
                }
                finally
                {
                    sb.Dispose();
                }

                jsonWriter.WritePropertyName(options.PayloadPropertyName);
                JsonSerializer.Serialize(jsonWriter, state.Payload, options.JsonSerializerOptions);
            }
            else
            {
                if (state.Format != null)
                {
                    state.Format.FormatTo(ref writer, <#= CreateStateParameterNames(i) #>);
                }
                else
                {
                    var writer2 = options.GetThradStaticUtf8JsonWriter(writer);
                    try
                    {
                        JsonSerializer.Serialize(writer2, state.Payload, options.JsonSerializerOptions);
                        writer2.Flush();
                    }
                    finally
                    {
                        writer2.Reset();
                    }
                }
            }
        }

        public void Return()
        {
            state = default;
            LogInfo = default!;
            cache.Enqueue(this);
        }
        
        public void SwitchCasePayload<TPayload1>(System.Action<IZLoggerEntry, TPayload1, object?> payloadCallback, object? state)
        {
            if (typeof(TPayload1) == typeof(TPayload))
            {
                payloadCallback(this, Unsafe.As<TPayload, TPayload1>(ref Unsafe.AsRef(this.state.Payload)), state);
            }
        }

        public object? GetPayload()
        {
            return state.Payload;
        }
    }

<# } #>
}
